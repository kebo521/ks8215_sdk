/*****************************菜单服务******************************
//功能-------  用于处理菜单创建、执行、显示、处理
//作者-------  邓国祖
//创作时间--20150604
******************************************************************************/
#include "comm_type.h"

#include "EvenMsg.h"

#include "xui_ui.h"
#include "xui_fb.h"
#include "xui_font.h"
#include "xui_gui.h"

#include "ui_menu.h"

#include "language.h"
#include "sdk/sys_sdk.h"


//============菜单显示处理用到的参数======================
typedef enum
{
	_GUI_MENU_SHOW,
	_GUI_MENU_PROCESS,
	_GUI_MENU_RUN,
	_GUI_MENU_RET,
	_GUI_MENU_QUT,
	_GUI_MENU_EXT,
} GUI_Menu_msg;
//============菜单处理结构==================================
typedef struct _CMenuUITable
{
	struct _CMenuUITable *pPrevious;	//回退指针
	u8		ShowState;		//-菜单处理所处的状态(GUI_Menu_msg)
	u8		TeamTatla;		//-菜单总条数
	u8		TeamCurr;		//-当前所选择的菜单项
	u8		ShowHead;		//-屏第一行显示的菜单项
	//----上面字节数必须是4的整数倍----------------
	char	*pAfterText;		//最后一行显示内容
	fMenuFun pKeyFunc;		//功能键处理内容
	char	*pKeyFuncTitle;		//功能键处标题
	fMenuFun pOutFunc;		//退出功能
	char	*pOutFuncTitle;		//退出功能标题
	APP_IndexH pUnifiedFunc;	//统一处理菜单接口
	FunFillColour fBackColour;
	u8				ShowFont;	//0显示菜单文字，0xff 不显示菜单文字
	u8				noUse[3];	
	int				TimeOutMs;		//菜单显示时间
	char  			*pTitle;		//菜单标题
	CMenuItemStru	pItem[1];		//菜单内容,菜单功能
}CMenuUITable;
static CMenuUITable *pMenuUiTable=NULL;
static CMenuItemStru tMenuEnterTag;

//====================================================================
//功能:   创建新的固定返回菜单(此过程需要申请内存空间)
//输入数据:pTitle 标题，pMenuText菜单显示项，tNum菜单总项数，pMenuFunc菜单的功能
//输出数据:无
//创作时间:  	20161128
//---------------------------------------------------------------
int APP_CreateNewMenuByStr(char *pTitle,int tNum,char* *pMenuText,const APP_IndexH pUnifiedFunc,int TimeOutMs)
{
	CMenuUITable *pNeTable;
	char *pText;
	u16 mLen,i,slen,len;
	/*
	if(pMenuUiTable!=NULL && pMenuUiTable->pMenuFunc == pMenuFunc)
	{//----同一个第非第一次创建，直接显示-------
		pMenuUiTable->ShowState=_GUI_MENU_SHOW;
		return;
	}*/
	mLen=sizeof(CMenuUITable) + sizeof(CMenuItemStru)*tNum;
	slen=0;
	for(i=0;i<tNum;i++)
	{
		len =	API_strlen(pMenuText[i])+1;
		slen += DfGetBeiSu(len,4);	//适应任意结构
	}
	pNeTable=(CMenuUITable*)malloc(mLen+slen);
	if(pNeTable == NULL)
	{//内存申请失败，退回之前的Ui
		LOG(LOG_INFO,"CreateNewMenuByStr malloc[%d] fail!\n",mLen+slen);
		return RET_ERR;
	}
	API_memset(pNeTable,0x00,mLen);
	//------------------------------------------------------------
	pText = (char*)&pNeTable->pItem[tNum];
	for(i=0;i<tNum;i++)
	{
		len =	API_strlen(pMenuText[i])+1;
		API_memcpy(pText,pMenuText[i],len);		
		pNeTable->pItem[i].pText=pText;
		pNeTable->pItem[i].pFunMenu=NULL;
		pText += DfGetBeiSu(len,4);	//适应任意结构
	}
	//----------------------------------------------------------
	pNeTable->TimeOutMs=TimeOutMs;
	pNeTable->pTitle=pTitle;
	pNeTable->pUnifiedFunc=pUnifiedFunc;
	pNeTable->TeamTatla=tNum;
	pNeTable->ShowState=_GUI_MENU_SHOW;
	pNeTable->pPrevious =pMenuUiTable;
	pMenuUiTable=pNeTable;
	return RET_OK;
}

//====================================================================
//功能:   创建新的内存菜单(运行菜单不使用外部空间，此过程需要申请较大内存空间)
//输入数据:pTitle 标题，tNum菜单总项数，pMenuAll菜单显示与功能
//输出数据:RET_OK创建成功，RET_ERR 创建失败
//创作时间:  	20151230
//---------------------------------------------------------------
int APP_CreateNewMenuByStruct(char *pTitle,int tNum,CMenuItemStru *pMenuAll,int TimeOutMs)
{
	CMenuUITable *pNeTable;
	int 		i;
	//----------------------------------------------------------
	pNeTable=(CMenuUITable*)malloc(sizeof(CMenuUITable)+sizeof(CMenuItemStru)*tNum);
	if(pNeTable == NULL)
	{	//内存申请失败，退回之前的Ui
	//	 LOG(LOG_INFO,"pMenuUiTable Null!\n");
		//APP_ShowMsg(pTitle,"pMenuUiTable Null",2000);
		return RET_ERR;
	}
	API_memset(pNeTable,0x00,sizeof(CMenuUITable));
	//--------------修改临时属性------------------
	for(i=0;i<tNum;i++)
	{
		pNeTable->pItem[i].pFunMenu=pMenuAll[i].pFunMenu;
		pNeTable->pItem[i].pText=pMenuAll[i].pText;
	}	
	//-------------写入标题信息-------
	pNeTable->TimeOutMs=TimeOutMs;
	pNeTable->pTitle = pTitle;
	pNeTable->TeamTatla=tNum;
	pNeTable->TeamCurr=0;	//默认选择项
	pNeTable->ShowState=_GUI_MENU_SHOW;
	pNeTable->pPrevious =pMenuUiTable;
	pMenuUiTable=pNeTable;
	return RET_OK;
}


//====================================================================
//功能:   将链表菜单转成结构菜单(此过程需要申请内存空间，菜单的大小级数视内存而定)
//作用:   将pStrlist中的菜单内容考到结构菜单中，并释放pStrlist(由ShowFlowMenu所申请)所对应的内在空间
//输入数据:pTitle 菜单标题,pStrlist 菜单数据链(显示内容，处理方式)
//输出数据:RET_OK创建成功，RET_ERR 创建失败
//创作时间:  	20170207
//---------------------------------------------------------------
int APP_CreateNewMenuByList(char* pTitle,CMenuListPar* pMenulist,int TimeOutMs)
{
	u8 i,MenuCount=0;
	u8 slen,TatleLen=0;
	char *pShowMsg;
	CMenuUITable *pNeTable;
	CMenuListPar *pNewList;
	if(pMenulist==NULL) return RET_ERR;
	pNewList=pMenulist;
	while(pNewList != NULL)
	{
		MenuCount++;
		slen=pNewList->TextLen+1;
		TatleLen += DfGetBeiSu(slen,4);	//适应任意结构
		pNewList=pNewList->pNext;
	}
	//----------------------------------------------------------
	pNeTable=(CMenuUITable*)malloc(sizeof(CMenuUITable)+sizeof(CMenuItemStru)*MenuCount +TatleLen);
	API_memset(pNeTable,0x00,sizeof(CMenuUITable));
	//--------------修改临时属性------------------
	pShowMsg=(char*)&pNeTable->pItem[MenuCount];
	for(i=0;i<MenuCount;i++)
	{
		API_memcpy(pShowMsg,pMenulist->Text,pMenulist->TextLen);
		pShowMsg[pMenulist->TextLen]='\0';

		pNeTable->pItem[i].pText = pShowMsg;
		pNeTable->pItem[i].pFunMenu=pMenulist->pFunMenu;

		slen=pNewList->TextLen+1;
		pShowMsg += DfGetBeiSu(slen,4);	//适应任意结构
		
		pNewList=pMenulist;
		pMenulist=pMenulist->pNext;
		free(pNewList);
	}
	//-------------------------------------------------------
	pNeTable->TimeOutMs=TimeOutMs;
	pNeTable->pTitle =pTitle;
	pNeTable->TeamTatla=MenuCount;
	pNeTable->ShowState= _GUI_MENU_SHOW;
	pNeTable->pPrevious =pMenuUiTable;
	pMenuUiTable=pNeTable;
	return RET_OK;
}


//====================================================================
//功能:  返回上一级(或上一段)菜单
//作用:   撤销CreateNewRamMenu所申请的内存空间
//输入数据:series 向上返回级数，series=0时，退出所有菜单,pEndMenu为空向上返回级数，pEndMenu不为空，返回到pEndMenu的上一级并退出显示处理
//输出数据:GUI_Menu_msg
//创作时间:  	20170317
//---------------------------------------------------------------
GUI_Menu_msg ReturnToPreviousMenu(u8 series,CMenuUITable *pEndMenu)  //RevocateMenuList
{
	CMenuUITable* pOldeMenu;
	while(pMenuUiTable!=NULL)
	{
		if(pMenuUiTable->pOutFunc)
			pMenuUiTable->pOutFunc(pMenuUiTable->pOutFuncTitle);
		if(pEndMenu == pMenuUiTable)
		{
			pMenuUiTable=pMenuUiTable->pPrevious;
			free(pEndMenu);
			return _GUI_MENU_EXT;
		}
		pOldeMenu=pMenuUiTable;
		pMenuUiTable=pMenuUiTable->pPrevious;
		free(pOldeMenu);
		if(series)
		{
			if((--series)==0)
			{
				if(pMenuUiTable)
					return _GUI_MENU_SHOW;
				return _GUI_MENU_EXT;
			}
		}
	}
	return _GUI_MENU_EXT;
}


//====================================================================
//功能:  向当前菜单添加其它功能键执行功能
//作用:  用于菜单需要增加额外功能
//输入数据:type 功能类型,pFunc功能执行函数，pFunTitle 功能标题(不支持栈空间)。
//输出数据:无
//---------------------------------------------------------------
void APP_AddCurrentMenuOtherFun(UI_MENU_ADD_TYPE type,void* pFunc,const char *pData)
{
	if(pMenuUiTable)
	{
		if(type==MENU_KEY_FUN)
		{
			pMenuUiTable->pKeyFunc	= (fMenuFun)pFunc;
			pMenuUiTable->pKeyFuncTitle = (char*)pData;
		}
		else if(type==MENU_OUT_FUN)
		{
			pMenuUiTable->pOutFunc	= (fMenuFun)pFunc;
			pMenuUiTable->pOutFuncTitle = (char*)pData;
		}
		else if(type==MENU_SHOW_AFT)
		{
			pMenuUiTable->pAfterText = (char*)pData;
		}
		else if(type==MENU_BACK_MAP)
		{
			pMenuUiTable->fBackColour	= (FunFillColour)pFunc;
			pMenuUiTable->ShowFont	= *pData;
		}
	}
}


//====================================================================
//功能: 进入指定菜单项
//作用: 菜单项返回时，可指定其进入项单项，而不是显示菜单
//输入数据:pTagFunc指定功能函数，pTagTitle 指定标题,pTagFunc与pTagTitle两者可选其一。
//输出数据:返回 EVENT_ENTER 告诉菜单进入指定项
//---------------------------------------------------------------
int APP_DesignatMenuItem(void* pTagFunc,char *pTagTitle)
{
	if(pMenuUiTable)
		pMenuUiTable->ShowState=_GUI_MENU_RUN;
	tMenuEnterTag.pFunMenu=(fMenuFun)pTagFunc;
	tMenuEnterTag.pText = pTagTitle;
	return EVENT_ENTER;
}

//====================================================================
//功能:  单项菜单显示。
//输入数据:pMenu 菜单结构，index索引项，line行号(1~n)
//输出数据:pOutShow 显示结果
//---------------------------------------------------------------
void ShowMenuItem(void *pMenu,int index,int line,char *pOutShow)
{
	CMenuItemStru *pItem=(CMenuItemStru *)pMenu;
	API_sprintf(pOutShow,"%d.%s",line,pItem[index].pText);
}
//====================================================================
//功能:  标准SDK显示处理菜单，
//作用:  显示，并处理链表pMenuUiTable里面的菜单
//输入数据:无
//输出数据:菜单执行结果
//注:改变了 pWindow 需要重新show,没改变不用
//---------------------------------------------------------------
int APP_ShowProsseMenu(void)
{
	CMenuUITable *pStartMenuAdd=pMenuUiTable;
	u32 event,ret;
	while(pMenuUiTable)
	{
		if(pMenuUiTable->ShowState == _GUI_MENU_RUN)
		{
			goto Addr_SCAD_MenuItem;
		}
		if(pMenuUiTable->ShowFont == 0xff)
		{//----不显示字符--------
			API_GUI_CreateWindow(NULL,NULL,TCANCEL,pMenuUiTable->fBackColour);
			API_GUI_Show();
		}
		else
		{
			if(pMenuUiTable->fBackColour==NULL) pMenuUiTable->fBackColour=&API_FillMenuBack;
			API_GUI_CreateWindow(pMenuUiTable->pTitle,NULL,TCANCEL,pMenuUiTable->fBackColour);
			API_GUI_Menu(pMenuUiTable->pItem,ShowMenuItem,pMenuUiTable->TeamTatla,pMenuUiTable->TeamCurr,pMenuUiTable->ShowHead,pMenuUiTable->pAfterText,pMenuUiTable->pKeyFunc);
			API_GUI_Show();
		}
		//----------显示菜单---------------------
	//	pMenuUiTable->ShowState=_GUI_MENU_PROCESS;
		//----------处理菜单----------------------
		event=API_WaitEvent(pMenuUiTable->TimeOutMs,EVENT_UI|EVENT_ABS,EVENT_NONE);	
		if(event==EVENT_INDEX)
		{
			int index,head;
			index=API_GUI_Menu_GetInxAndHear(&head);
			ret = EVENT_NONE;
			if(index<pMenuUiTable->TeamTatla)
			{
				pMenuUiTable->ShowHead=head;
			Addr_Specify_menu:
				pMenuUiTable->TeamCurr=index;
				pMenuUiTable->ShowState=_GUI_MENU_SHOW; //执行完显示菜单
				if(pMenuUiTable->pUnifiedFunc)
				{//-----统一菜单处理----------
					ret=(*pMenuUiTable->pUnifiedFunc)(pMenuUiTable->pItem[index].pText,index);
				}
				else if(pMenuUiTable->pItem[index].pFunMenu)
				{//-----独立菜单处理------
					ret=(*pMenuUiTable->pItem[index].pFunMenu)(pMenuUiTable->pItem[index].pText);
				}
				if(ret&EVENT_QUIT)		//指定退出多少层
				{
					if(_GUI_MENU_EXT == ReturnToPreviousMenu(ret&0x0F,pStartMenuAdd))
						break;
				}
				if(ret&EVENT_ENTER)		//指定进入菜单
				{
					while(pMenuUiTable)
					{
					Addr_SCAD_MenuItem:
						for(index=0;index<pMenuUiTable->TeamTatla;index++)
						{
							if(tMenuEnterTag.pFunMenu)
							{
								if(tMenuEnterTag.pFunMenu == pMenuUiTable->pItem[index].pFunMenu)
									goto Addr_Specify_menu;
							}
							if(tMenuEnterTag.pText)
							{
								if(strcmp(tMenuEnterTag.pText,pMenuUiTable->pItem[index].pText) == 0)
									goto Addr_Specify_menu;
							}
						}
						if(_GUI_MENU_EXT == ReturnToPreviousMenu(1,pStartMenuAdd))
							break;
					}
					break;
				}
			}
		}
		else if(event==EVENT_CANCEL)
		{
			if(_GUI_MENU_EXT == ReturnToPreviousMenu(1,pStartMenuAdd))
				break;
	//		else
	//			pMenuUiTable->ShowState=_GUI_MENU_SHOW;
		}
		else if(event==EVENT_TIMEOUT)
		{
			if(_GUI_MENU_EXT == ReturnToPreviousMenu(1,pStartMenuAdd))
				break;
	//		else
	//			pMenuUiTable->ShowState=_GUI_MENU_SHOW;
		}
		else if(event==(EVENT_KEY|3))//K_FUNC
		{
			if(pMenuUiTable->pKeyFunc==NULL)
				continue;
			pMenuUiTable->ShowState=_GUI_MENU_SHOW; //执行完显示菜单
			ret=pMenuUiTable->pKeyFunc(pMenuUiTable->pKeyFuncTitle);
			if(EVENT_QUIT&ret)
			{//-----退出所有菜单----------
				ReturnToPreviousMenu(ret&EVENT_INDEX,pStartMenuAdd);
				break;
			}
		}
	}
	return ret;
}
//===================固定菜单处理=================================================
void ShowFixedMenutem(void *pMenu,int index,int line,char *pOutShow)
{
	tMenuItemStru *pItem=(tMenuItemStru *)pMenu;
	API_sprintf(pOutShow,"%d.%s",line,pItem[index].pText);
}

int APP_ShowFixedMenu(char* pTitle,const FixedMenuUITable *pFixedMenu,void* pTagFunc)
{
	int ret;
	u8 ShowHead=0,TeamCurr=0,TeamTatla;
	
	if(pFixedMenu->pInFunc)
	{
		ret=(*pFixedMenu->pInFunc)(pTitle);
		if(ret == EVENT_QUIT) return ret;
	}
	TeamTatla=pFixedMenu->TeamTatla;
	if(TeamTatla == 0)
	{
		while(pFixedMenu->pItem[TeamTatla++].pText);
	}
	if(pTagFunc)
	{
		tMenuEnterTag.pFunMenu=(fMenuFun)pTagFunc;
		goto Addr_SCAD_FixedMenuItem;
	}
	while(1)
	{
 		API_GUI_CreateWindow(pTitle,NULL,TCANCEL,API_FillMenuBack);
		API_GUI_Menu(pFixedMenu->pItem,ShowFixedMenutem,TeamTatla,TeamCurr,ShowHead,NULL,NULL);
		API_GUI_Show();
		ret=API_WaitEvent(pFixedMenu->TimeOutMs,EVENT_UI|EVENT_ABS,EVENT_NONE);	
		if(ret == EVENT_INDEX)
		{
			TeamCurr=API_GUI_Menu_GetInxAndHear(&ret);
			if(TeamCurr < TeamTatla)
			{
				ShowHead=ret;
			Addr_Specify_Fixedmenu:
				switch(pFixedMenu->pItem[TeamCurr].FunType)
				{
					case FUN_MENU_F:
						ret=(*(fMenuFun)pFixedMenu->pItem[TeamCurr].pFun)(pFixedMenu->pItem[TeamCurr].pText);
						break;
					case FUN_MENU_I:
						ret=(*(APP_IndexH)pFixedMenu->pItem[TeamCurr].pFun)(pFixedMenu->pItem[TeamCurr].pText , TeamCurr);
						break;
					case FUN_MENU_G:
						ret=APP_ShowFixedMenu(pFixedMenu->pItem[TeamCurr].pText,(FixedMenuUITable *)pFixedMenu->pItem[TeamCurr].pFun ,NULL);
						break;
				}
				if(ret&EVENT_QUIT)		//退出所有菜单
				{
					if(ret&EVENT_INDEX)
					{
						ret--;
						break;
					}
 				}
				if(ret&EVENT_ENTER)		//指定进入菜单
				{
					if(ret&EVENT_INDEX)	//指定进入菜单外部
						break;
				Addr_SCAD_FixedMenuItem:
					for(TeamCurr=0;TeamCurr<TeamTatla;TeamCurr++)
					{
						if(tMenuEnterTag.pFunMenu)
						{
							if((void*)tMenuEnterTag.pFunMenu == pFixedMenu->pItem[TeamCurr].pFun)
								goto Addr_Specify_Fixedmenu;
						}
						if(tMenuEnterTag.pText)
						{
							if(strcmp(tMenuEnterTag.pText,pFixedMenu->pItem[TeamCurr].pText) == 0)
								goto Addr_Specify_Fixedmenu;
						}
					}
					break;
				}
			}
		}
		else if(ret==EVENT_CANCEL || ret==EVENT_TIMEOUT)
		{
			break;
		}
	}
	if(pFixedMenu->pOutFunc)
	{
		(*pFixedMenu->pOutFunc)(pTitle);
	}
	return ret;
}



